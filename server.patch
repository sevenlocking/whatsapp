 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/banco 2/banco 2/server.js b/banco 2/banco 2/server.js
index 325bb4afe88e18785ba61ace5068007b9a143054..34dce9405682c3ae702c865b6be08c75f3188e8c 100644
--- a/banco 2/banco 2/server.js	
+++ b/banco 2/banco 2/server.js	
@@ -1,40 +1,39 @@
 // Carregar vari√°veis de ambiente do arquivo .env
 require('dotenv').config();
 
 const express = require('express');
 const cors = require('cors');
 const path = require('path');
-const { execSync } = require('child_process');
 const fs = require('fs');
 
 const app = express();
 const PORT = process.env.PORT || 3001;
 
-// Configura√ß√µes - Token PayZu carregado do arquivo .env
-const PAYZU_TOKEN = process.env.PAYZU_TOKEN;
-const PAYZU_BASE_URL = 'https://api.payzu.processamento.com/v1';
+// Configura√ß√µes - Token CREDPIX carregado do arquivo .env (modo legado)
+const CREDPIX_TOKEN = process.env.CREDPIX_TOKEN;
+const CREDPIX_BASE_URL = process.env.CREDPIX_BASE_URL || '';
 
 // N√∫meros autorizados a usar o bot (separados por v√≠rgula no .env)
 const AUTHORIZED_NUMBERS = process.env.AUTHORIZED_NUMBERS
     ? process.env.AUTHORIZED_NUMBERS.split(',').map(n => n.trim())
     : [];
 
 // IPs autorizados a acessar o painel admin (separados por v√≠rgula no .env)
 const ADMIN_ALLOWED_IPS = process.env.ADMIN_ALLOWED_IPS
     ? process.env.ADMIN_ALLOWED_IPS.split(',').map(ip => ip.trim())
     : [];
 
 /**
  * Validar CPF brasileiro (algoritmo dos d√≠gitos verificadores)
  * @param {string} cpf - CPF com 11 d√≠gitos (apenas n√∫meros)
  * @returns {boolean} - true se CPF v√°lido, false se inv√°lido
  */
 function isValidCPF(cpf) {
     // Remover caracteres n√£o num√©ricos
     cpf = cpf.replace(/\D/g, '');
 
     // Deve ter 11 d√≠gitos
     if (cpf.length !== 11) return false;
 
     // CPFs com todos os d√≠gitos iguais s√£o inv√°lidos
     if (/^(\d)\1{10}$/.test(cpf)) return false;
@@ -50,50 +49,80 @@ function isValidCPF(cpf) {
 
     // Validar segundo d√≠gito verificador
     sum = 0;
     for (let i = 0; i < 10; i++) {
         sum += parseInt(cpf.charAt(i)) * (11 - i);
     }
     remainder = (sum * 10) % 11;
     if (remainder === 10 || remainder === 11) remainder = 0;
     if (remainder !== parseInt(cpf.charAt(10))) return false;
 
     return true;
 }
 
 /**
  * Formatar valor monet√°rio no padr√£o brasileiro (R$ 1.234,56)
  * @param {number} value - Valor em reais (pode ser float)
  * @returns {string} - Valor formatado
  */
 function formatBRL(value) {
     return parseFloat(value).toLocaleString('pt-BR', {
         minimumFractionDigits: 2,
         maximumFractionDigits: 2
     });
 }
 
+async function getUserByChatId(chatid) {
+    const rows = await db.query(
+        `SELECT id, chatid, nome, saldo, limite_saque, reservado, user_token, platform_token, status
+         FROM users
+         WHERE chatid = ?
+         LIMIT 1`,
+        [chatid]
+    );
+    return rows[0] || null;
+}
+
+async function updateUserBalance(chatid, delta, reason = null) {
+    const user = await getUserByChatId(chatid);
+    if (!user) return null;
+
+    const saldoAntes = parseFloat(user.saldo || 0);
+    const saldoDepois = parseFloat((saldoAntes + delta).toFixed(2));
+
+    await db.query(
+        'UPDATE users SET saldo = ? WHERE chatid = ?',
+        [saldoDepois, chatid]
+    );
+
+    return {
+        saldoAntes,
+        saldoDepois,
+        reason
+    };
+}
+
 /**
  * Middleware para restringir acesso ao painel admin por IP
  * Funciona com proxies (Railway, Heroku, etc) usando X-Forwarded-For
  */
 function requireAdminIP(req, res, next) {
     // Se n√£o h√° IPs configurados, permite acesso (desenvolvimento)
     if (ADMIN_ALLOWED_IPS.length === 0) {
         return next();
     }
 
     // Obter IP real do cliente (considerando proxies)
     const forwardedFor = req.headers['x-forwarded-for'];
     const realIP = forwardedFor
         ? forwardedFor.split(',')[0].trim()  // Primeiro IP da lista
         : req.connection.remoteAddress || req.socket.remoteAddress;
 
     // Normalizar IPv6 localhost para IPv4
     const normalizedIP = realIP === '::1' ? '127.0.0.1' : realIP;
 
     // Verificar se o IP est√° na lista permitida
     const isAllowed = ADMIN_ALLOWED_IPS.some(allowedIP => {
         // Suporte a CIDR b√°sico ou IP exato
         if (allowedIP.includes('/')) {
             // Por simplicidade, s√≥ verifica prefixo para /24, /16, /8
             const [baseIP, mask] = allowedIP.split('/');
@@ -115,93 +144,94 @@ function requireAdminIP(req, res, next) {
             error: 'Acesso negado',
             message: 'Seu IP n√£o est√° autorizado a acessar o painel admin'
         });
     }
 
     // IP permitido
     console.log(`Acesso admin permitido - IP: ${normalizedIP}`);
     next();
 }
 
 // Nota: MULTI_TENANT_MODE √© verificado ap√≥s importar tenantService (mais abaixo)
 
 // Middlewares
 app.use(cors());
 app.use(express.json());
 app.use(express.urlencoded({ extended: true })); // Para webhooks
 app.use(require('cookie-parser')()); // Para sess√µes admin
 app.use(express.static(path.join(__dirname)));
 
 // Importar servi√ßos WhatsApp, IA, Contatos, M√≠dia, Transa√ß√µes e Comprovantes
 const whatsappService = require('./whatsapp-zapi');
 const aiService = require('./ai-chat');
 const contactsService = require('./contacts');
 const mediaService = require('./media-service');
 const transactionsService = require('./transactions');
+const db = require('./db');
 const receiptGenerator = require('./receipt-generator');
 
 // Importar servi√ßos Multi-Tenant, Autentica√ß√£o Admin e Bots
 const tenantService = require('./tenants');
 const adminAuth = require('./admin-auth');
 const botService = require('./bots');
 
 // Middleware para parsing de cookies (necess√°rio para sess√µes admin)
 const cookieParser = require('cookie-parser');
 
 // Verificar modo de opera√ß√£o (multi-tenant ou single-tenant)
 const MULTI_TENANT_MODE = tenantService.listTenants().length > 0;
 
 if (MULTI_TENANT_MODE) {
     console.log('\nüè¢ MODO MULTI-TENANT ATIVO');
     const stats = tenantService.getStats();
     console.log(`   Clientes cadastrados: ${stats.total} (${stats.active} ativos)`);
     console.log(`   N√∫meros autorizados: ${stats.totalNumbers}`);
 } else {
-    // Modo single-tenant (legado) - requer PAYZU_TOKEN no .env
-    if (!PAYZU_TOKEN) {
-        console.warn('\n AVISO: Nenhum cliente cadastrado e PAYZU_TOKEN n√£o configurado!');
-        console.warn('   Acesse /admin para cadastrar clientes ou configure PAYZU_TOKEN no .env.\n');
+    // Modo single-tenant (legado) - requer CREDPIX_TOKEN no .env
+    if (!CREDPIX_TOKEN) {
+        console.warn('\n AVISO: Nenhum cliente cadastrado e CREDPIX_TOKEN n√£o configurado!');
+        console.warn('   Acesse /admin para cadastrar clientes ou configure CREDPIX_TOKEN no .env.\n');
     } else {
         console.log('\nMODO SINGLE-TENANT (legado)');
-        console.log('   Usando PAYZU_TOKEN do .env');
+        console.log('   Usando CREDPIX_TOKEN do .env');
 
         // Avisar se n√£o h√° n√∫meros autorizados configurados
         if (AUTHORIZED_NUMBERS.length === 0) {
             console.warn('   Nenhum n√∫mero autorizado configurado!');
             console.warn('   Qualquer pessoa poder√° usar o bot.');
         } else {
             console.log('   N√∫meros autorizados:', AUTHORIZED_NUMBERS.length);
         }
     }
 }
 
 // URL base para callbacks (Railway ou localhost)
 const BASE_URL = process.env.RAILWAY_PUBLIC_DOMAIN
     ? `https://${process.env.RAILWAY_PUBLIC_DOMAIN}`
     : `http://localhost:${PORT}`;
 
-console.log(`üì° URL de Callback: ${BASE_URL}/webhook/payzu`);
+console.log(`üì° URL de Callback: ${BASE_URL}/webhook/credpix`);
 
 // Armazenar contexto de imagens pendentes (quando usu√°rio manda foto e depois valor)
 // Formato: { phoneNumber: { pixKey, pixKeyType, timestamp } }
 const pendingImageTransfers = new Map();
 
 // Armazenar comandos de √°udio pendentes de confirma√ß√£o
 // Formato: { phoneNumber: { transcription, command, timestamp } }
 const pendingAudioCommands = new Map();
 
 // Armazenar transfer√™ncias PIX pendentes de confirma√ß√£o manual
 // Formato: { phoneNumber: { command, timestamp } }
 const pendingWithdrawConfirmations = new Map();
 
 // Armazenar estornos pendentes de confirma√ß√£o
 // Formato: { phoneNumber: { transaction, timestamp } }
 const pendingRefundConfirmations = new Map();
 
 // Armazenar confirma√ß√µes de CPF/telefone pendentes
 // Formato: { phoneNumber: { command, timestamp } }
 const pendingCPFConfirmations = new Map();
 
 // Armazenar √∫ltimos c√≥digos PIX gerados (para bot√£o "reenviar c√≥digo")
 // Formato: { phoneNumber: { pixCode, timestamp } }
 const lastGeneratedPixCodes = new Map();
 
@@ -242,52 +272,52 @@ setInterval(() => {
         if (now - data.timestamp > TIMEOUT) {
             pendingCPFConfirmations.delete(phone);
             console.log(`üßπ Limpou confirma√ß√£o de CPF/telefone pendente de: ${phone}`);
         }
     }
 
     // C√≥digos PIX expiram em 24 horas
     const PIX_TIMEOUT = 24 * 60 * 60 * 1000;
     for (const [phone, data] of lastGeneratedPixCodes.entries()) {
         if (now - data.timestamp > PIX_TIMEOUT) {
             lastGeneratedPixCodes.delete(phone);
             console.log(`üßπ Limpou c√≥digo PIX expirado de: ${phone}`);
         }
     }
 }, 60 * 1000);
 
 // ========== WEBHOOK WHATSAPP (Z-API) ==========
 
 // Webhook para receber mensagens do WhatsApp via Z-API
 app.post('/webhook/whatsapp', async (req, res) => {
     try {
         // Responder imediatamente para n√£o deixar Z-API esperando
         res.status(200).send('OK');
 
         // ========== IDENTIFICA√á√ÉO DO BOT ==========
-        // O bot √© identificado via query parameter: /webhook/whatsapp?bot=payzu
-        const botId = req.query.bot || 'payzu'; // Default para PayZu
+        // O bot √© identificado via query parameter: /webhook/whatsapp?bot=credpix
+        const botId = req.query.bot || 'credpix'; // Default para CREDPIX
         const currentBot = botService.getBotById(botId);
 
         if (!currentBot) {
             console.log(`\nüö´ Bot n√£o encontrado: ${botId}`);
             return;
         }
 
         // Obter credenciais Z-API do bot e branding
         const zapiCredentials = botService.getBotZapiCredentials(botId);
         const botBranding = botService.getBotBranding(botId);
 
         // Helpers locais que j√° incluem as credenciais do bot atual
         const sendMessage = (to, msg) => whatsappService.sendMessage(to, msg, zapiCredentials);
         const sendImage = (to, img, caption) => whatsappService.sendImage(to, img, caption, zapiCredentials);
         const sendButtons = (to, msg, btns) => whatsappService.sendButtons(to, msg, btns, zapiCredentials);
 
         console.log(`\nü§ñ BOT: ${currentBot.name} (${botId})`);
         console.log(`Z-API Instance: ${zapiCredentials.instance?.substring(0, 10)}...`);
 
         // Log completo do payload para debug
         console.log('üîç DEBUG - Payload recebido:', JSON.stringify(req.body, null, 2));
 
         // Z-API pode enviar em diferentes formatos, vamos tratar todos
         let phoneNumber;
         let message;
@@ -385,109 +415,109 @@ app.post('/webhook/whatsapp', async (req, res) => {
             // Imagem pode ter legenda
             message = req.body.image.caption || message;
         } else if (req.body.data?.image) {
             imageUrl = req.body.data.image.imageUrl || req.body.data.image.url;
             phoneNumber = phoneNumber || req.body.data.phone;
             message = req.body.data.image.caption || message;
         }
 
         // Validar se temos pelo menos o n√∫mero
         if (!phoneNumber) {
             console.log('N√∫mero n√£o encontrado no webhook. Ignorando...');
             return;
         }
 
         // Validar se temos algum conte√∫do (texto, √°udio ou imagem)
         if (!message && !audioUrl && !imageUrl) {
             console.log('Nenhum conte√∫do (texto/√°udio/imagem) no webhook. Ignorando...');
             return;
         }
 
         console.log(`\nMensagem recebida de: ${phoneNumber}`);
         console.log(`üí¨ Conte√∫do: ${message}`);
 
         // CONTROLE DE ACESSO - Multi-tenant ou Single-tenant (legado)
         let currentTenant = null;
-        let currentPayzuToken = null;
+        let currentCredpixToken = null;
         let currentPixKey = null;
 
         // Tentar buscar tenant pelo n√∫mero
         currentTenant = tenantService.getTenantByPhone(phoneNumber);
 
         if (currentTenant) {
             // Multi-tenant: usar credenciais do tenant
             if (!currentTenant.active) {
                 console.log(`\nüö´ Cliente INATIVO: ${currentTenant.name}`);
                 return;
             }
 
             // Verificar se o cliente tem permiss√£o para usar este bot
             if (currentTenant.allowedBots && currentTenant.allowedBots.length > 0) {
                 if (!currentTenant.allowedBots.includes(botId)) {
                     console.log(`\nüö´ Cliente "${currentTenant.name}" n√£o autorizado para bot ${botId}`);
                     console.log(`   Bots permitidos: ${currentTenant.allowedBots.join(', ')}`);
                     return; // Ignora silenciosamente
                 }
             }
 
-            currentPayzuToken = currentTenant.payzuToken;
+            currentCredpixToken = currentTenant.platformToken;
             currentPixKey = currentTenant.myPixKey;
             console.log(`\nüè¢ MULTI-TENANT: Cliente "${currentTenant.name}" (${currentTenant.id}) via bot ${botId}`);
         } else {
             // Modo legado: verificar AUTHORIZED_NUMBERS
             if (AUTHORIZED_NUMBERS.length > 0) {
                 const cleanPhone = phoneNumber.replace(/\D/g, '');
                 const isAuthorized = AUTHORIZED_NUMBERS.some(authorizedNumber => {
                     const cleanAuthorized = authorizedNumber.replace(/\D/g, '');
                     let match = cleanPhone.includes(cleanAuthorized) || cleanAuthorized.includes(cleanPhone);
 
                     // Verificar com/sem nono d√≠gito
                     if (!match && cleanPhone.length >= 10 && cleanAuthorized.length >= 10) {
                         const phonePrefix = cleanPhone.substring(0, 4);
                         const authorizedPrefix = cleanAuthorized.substring(0, 4);
                         if (phonePrefix === authorizedPrefix) {
                             const phoneRest = cleanPhone.substring(4);
                             const authorizedRest = cleanAuthorized.substring(4);
                             if (phoneRest.startsWith('9') && phoneRest.substring(1) === authorizedRest) match = true;
                             else if (authorizedRest.startsWith('9') && authorizedRest.substring(1) === phoneRest) match = true;
                         }
                     }
                     return match;
                 });
 
                 if (!isAuthorized) {
                     console.log(`\nüö´ Acesso NEGADO - N√∫mero n√£o autorizado: ${phoneNumber}`);
                     return;
                 }
-            } else if (!PAYZU_TOKEN) {
-                // Sem tenants, sem AUTHORIZED_NUMBERS e sem PAYZU_TOKEN
-                console.log(`\nüö´ Sem clientes cadastrados e sem PAYZU_TOKEN configurado`);
+            } else if (!CREDPIX_TOKEN) {
+                // Sem tenants, sem AUTHORIZED_NUMBERS e sem CREDPIX_TOKEN
+                console.log(`\nüö´ Sem clientes cadastrados e sem CREDPIX_TOKEN configurado`);
                 return;
             }
 
             // Modo legado: usar credenciais do .env
-            currentPayzuToken = PAYZU_TOKEN;
+            currentCredpixToken = CREDPIX_TOKEN;
             currentPixKey = process.env.MY_PIX_KEY;
             console.log(`\nSINGLE-TENANT: Usando credenciais do .env`);
         }
 
         // ID do dono dos contatos (tenant ID ou phoneNumber para legado)
         const contactsOwnerId = currentTenant ? currentTenant.id : phoneNumber;
 
         // ========== VERIFICAR CONFIRMA√á√ÉO DE TRANSFER√äNCIA PIX PENDENTE ==========
         if (message && pendingWithdrawConfirmations.has(phoneNumber)) {
             const pending = pendingWithdrawConfirmations.get(phoneNumber);
             const msgLower = message.toLowerCase().trim();
 
             // Verificar se √© confirma√ß√£o (inclui resposta de bot√£o)
             if (msgLower === 'sim' || msgLower === 's' || msgLower === 'y' || msgLower === 'yes' ||
                 msgLower === 'confirmar' || msgLower === 'confirma' || msgLower === 'ok' ||
                 msgLower === 'enviar' || msgLower === 'pode enviar' || msgLower === 'manda' || msgLower === 'envia' ||
                 msgLower === 'sim, enviar' || msgLower.includes('sim, enviar')) {
                 console.log(`Usu√°rio confirmou transfer√™ncia PIX`);
                 pendingWithdrawConfirmations.delete(phoneNumber);
 
                 await sendMessage(phoneNumber, 'Confirmado! Enviando PIX...');
 
                 // Executar o comando salvo
                 await executePixCommand(pending.command, phoneNumber, { contactsOwnerId, zapiCredentials, botBranding, botId });
                 return;
@@ -1053,122 +1083,144 @@ app.post('/webhook/whatsapp', async (req, res) => {
             });
 
             // Enviar mensagem de confirma√ß√£o com BOT√ïES
             const confirmMsg = `*CONFIRMAR TRANSFER√äNCIA PIX*\n\n` +
                 `Valor: *R$ ${valor}*\n` +
                 `Para: ${destino}\n\n` +
                 `‚è∞ _Expira em 5 minutos_`;
 
             await sendButtons(phoneNumber, confirmMsg, [
                 { id: 'sim', label: '‚úÖ Sim, enviar' },
                 { id: 'nao', label: '‚ùå Cancelar' }
             ]);
             console.log(`‚è≥ Aguardando confirma√ß√£o de PIX de ${phoneNumber}: R$ ${valor}`);
             return;
         }
 
         // Executar comando PIX (para outros comandos)
         await executePixCommand(command, phoneNumber, { contactsOwnerId, zapiCredentials, botBranding, botId });
 
     } catch (error) {
         console.error('üí• Erro no webhook:', error.message);
         console.error('Stack:', error.stack);
     }
 });
 
-// ========== WEBHOOK PAYZU (Confirma√ß√µes de Transa√ß√£o) ==========
+// ========== WEBHOOK CREDPIX (Confirma√ß√µes de Transa√ß√£o) ==========
 
-app.post('/webhook/payzu', async (req, res) => {
-    // Responder imediatamente com 200 OK (requisito PayZu: < 10 segundos)
+app.post('/webhook/credpix', async (req, res) => {
+    // Responder imediatamente com 200 OK (requisito CREDPIX: < 10 segundos)
     res.status(200).send('OK');
 
     try {
-        console.log('\nüì• WEBHOOK PAYZU RECEBIDO:');
+        console.log('\nüì• WEBHOOK CREDPIX RECEBIDO:');
         console.log(JSON.stringify(req.body, null, 2));
 
         const {
             id,
             status,
             type,
             amount,
             pixKey,
             endToEndId,
             paidAt,
             createdAt,
             // Dados do pagador (PIX In) - quem pagou
             payerName,
             payerDocument,
             payerInstitutionName,
             payerInstitutionIspb,
             // Dados da conta que gerou (PIX Out) - sua conta
             generatedName,
             generatedDocument,
             generatedInstitutionName,
             generatedInstitutionIspb,
             // Dados do recebedor (PIX Out) - quem recebeu
             receiverName,
             receiverDocument,
             receiverInstitutionName,
             receiverInstitutionIspb,
             // Dados de estorno (quando status = REFUNDED)
             refundAmount,
             refundStatus,
             refundReason,
             refundEndToEndId,
             refundedAt
         } = req.body;
 
         if (!id) {
             console.log('Webhook sem ID de transa√ß√£o');
             return;
         }
 
         // Buscar transa√ß√£o registrada
-        const transaction = transactionsService.getTransaction(id);
+        const transaction = await transactionsService.getTransaction(id);
 
         if (!transaction) {
             console.log(`Transa√ß√£o ${id} n√£o encontrada no registro local`);
             // Mesmo assim, atualizar se existir
             return;
         }
 
         const phoneNumber = transaction.phoneNumber;
         const previousStatus = transaction.status;
 
         // Obter branding e credenciais Z-API do bot que processou esta transa√ß√£o
-        const transactionBotId = transaction.botId || 'payzu';
+        const transactionBotId = transaction.botId || 'credpix';
         const botBranding = botService.getBotBranding(transactionBotId);
         const zapiCredentials = botService.getBotZapiCredentials(transactionBotId);
         console.log(`üé® Bot da transa√ß√£o: ${transactionBotId} (${botBranding?.name || 'N/A'})`);
 
         // Helpers para enviar mensagens pelo bot correto
         const sendMessage = (to, msg) => whatsappService.sendMessage(to, msg, zapiCredentials);
         const sendImage = (to, img, caption) => whatsappService.sendImage(to, img, caption, zapiCredentials);
         const sendButtons = (to, msg, btns) => whatsappService.sendButtons(to, msg, btns, zapiCredentials);
 
         // Atualizar status da transa√ß√£o
-        transactionsService.updateTransaction(id, status, req.body);
+        await transactionsService.updateTransaction(id, status, req.body);
+
+        // Atualizar saldo quando transa√ß√£o √© conclu√≠da
+        if (status === 'COMPLETED') {
+            const amountValue = parseFloat(amount || 0);
+            const isDeposit = type === 'DEPOSIT' || transaction.type === 'pix_in';
+            const delta = isDeposit ? amountValue : -amountValue;
+            const balanceSnapshot = await updateUserBalance(phoneNumber, delta, 'transaction_completed');
+
+            if (balanceSnapshot) {
+                if (isDeposit) {
+                    await db.query(
+                        'UPDATE pagamentos SET saldo_antes = ?, saldo_depois = ? WHERE identifier = ?',
+                        [balanceSnapshot.saldoAntes, balanceSnapshot.saldoDepois, id]
+                    );
+                } else {
+                    await db.query(
+                        'UPDATE saques_pix SET saldoantes = ?, saldodepois = ? WHERE txid = ?',
+                        [balanceSnapshot.saldoAntes, balanceSnapshot.saldoDepois, id]
+                    );
+                }
+            }
+        }
 
         // S√≥ notificar se o status mudou
         if (status === previousStatus) {
             console.log(`‚ÑπÔ∏è Status n√£o mudou: ${status}`);
             return;
         }
 
         console.log(`Notificando ${phoneNumber} sobre transa√ß√£o ${id}`);
 
         // Formatar valor
         const valorFormatado = typeof amount === 'number'
             ? `R$ ${amount.toFixed(2)}`
             : `R$ ${parseFloat(amount).toFixed(2)}`;
 
         // Log completo para debug
         console.log('DEBUG - Todos os campos do webhook:', {
             // Pagador (PIX In)
             payerName, payerDocument, payerInstitutionName,
             // Gerador da transa√ß√£o (sua conta)
             generatedName, generatedDocument, generatedInstitutionName,
             // Recebedor (PIX Out)
             receiverName, receiverDocument, receiverInstitutionName
         });
 
         // Notificar usu√°rio baseado no tipo e status
@@ -1254,51 +1306,51 @@ app.post('/webhook/payzu', async (req, res) => {
                             `Valor estornado: *${refundValueFormatado}*\n\n` +
                             `O valor retornou ao seu saldo.`;
                     } else {
                         message = `*PIX ESTORNADO*\n\n` +
                             `O PIX de ${refundValueFormatado} foi estornado.\n` +
                             `O valor retornou ao seu saldo.`;
                     }
 
                     // Gerar comprovante de estorno
                     try {
                         const receiptData = {
                             type: 'refund',
                             amount: refundValue,
                             originalAmount: isPartialRefund ? originalValue : null,
                             isPartialRefund: isPartialRefund,
                             transactionId: id,
                             refundReason: refundReason || 'Estorno solicitado',
                             refundEndToEndId: refundEndToEndId,
                             // Quem fez o estorno (recebedor original do PIX)
                             payerName: receiverName || 'N/A',
                             payerDocument: receiverDocument || '',
                             payerBank: receiverInstitutionName || 'N/A',
                             // Quem recebe o estorno (voc√™)
                             receiverName: generatedName || payerName || 'N/A',
                             receiverDocument: generatedDocument || payerDocument || '',
-                            receiverBank: generatedInstitutionName || payerInstitutionName || 'PayZu'
+                            receiverBank: generatedInstitutionName || payerInstitutionName || 'CREDPIX'
                         };
 
                         const receiptBase64 = await receiptGenerator.generateReceiptBase64(receiptData, botBranding);
 
                         let caption = `‚Ü©Ô∏è *ESTORNO RECEBIDO*\n\n` +
                             `Valor: R$ ${refundValue.toFixed(2)}`;
 
                         if (isPartialRefund) {
                             caption += ` _(de R$ ${originalValue.toFixed(2)})_`;
                         }
 
                         if (refundReason) {
                             caption += `\nMotivo: ${refundReason}`;
                         }
 
                         await sendImage(phoneNumber, receiptBase64, caption);
                         message = null; // N√£o enviar mensagem de texto, s√≥ o comprovante
                         console.log('Comprovante de estorno recebido enviado');
                     } catch (receiptError) {
                         console.error('Erro ao gerar comprovante de estorno:', receiptError.message);
                         // Mant√©m a mensagem de texto como fallback
                     }
                     break;
             }
         }
@@ -1428,217 +1480,147 @@ app.post('/webhook/payzu', async (req, res) => {
                     ]);
                 }
 
             } catch (receiptError) {
                 console.error('Erro ao gerar comprovante:', receiptError.message);
                 console.error('Stack:', receiptError.stack);
                 // Fallback: enviar mensagem de texto
                 const isDepositFallback = type === 'DEPOSIT' || transaction.type === 'pix_in';
                 const fallbackMsg = isDepositFallback
                     ? `*PIX RECEBIDO!*\n\nValor: *${valorFormatado}*\nPagador: ${payerName || 'N/A'}\nBanco: ${payerInstitutionName || 'N/A'}\nID: ${endToEndId || id}`
                     : `*PIX ENVIADO!*\n\nValor: *${valorFormatado}*\nRecebedor: ${receiverName || 'N/A'}\nBanco: ${receiverInstitutionName || 'N/A'}\nID: ${endToEndId || id}`;
                 await sendMessage(phoneNumber, fallbackMsg);
 
                 // Enviar bot√£o "Ver saldo" ap√≥s a notifica√ß√£o
                 await sendButtons(phoneNumber, 'Deseja ver seu saldo atualizado?', [
                     { id: 'ver_saldo', label: 'Ver saldo' }
                 ]);
             }
         } else if (message && phoneNumber) {
             // Enviar mensagem de texto para outros status
             await sendMessage(phoneNumber, message);
             console.log(`Notifica√ß√£o enviada para ${phoneNumber}`);
         }
 
     } catch (error) {
-        console.error('üí• Erro no webhook PayZu:', error.message);
+        console.error('üí• Erro no webhook CREDPIX:', error.message);
     }
 });
 
 // Executar comandos PIX via WhatsApp
 async function executePixCommand(command, phoneNumber, options = {}) {
     console.log('\n‚öôÔ∏è Executando comando:', command.action);
 
     // Resolver credenciais: op√ß√µes passadas > tenant > env
-    let payzuToken = options.payzuToken;
+    let platformToken = options.platformToken;
     let myPixKey = options.myPixKey;
     let contactsOwnerId = options.contactsOwnerId; // ID para contatos (tenant ou phone)
 
     // Credenciais Z-API, branding e ID do bot (opcionais)
     const zapiCredentials = options.zapiCredentials || null;
     const botBranding = options.botBranding || null;
-    const botId = options.botId || 'payzu'; // ID do bot para rastreamento
+    const botId = options.botId || 'credpix'; // ID do bot para rastreamento
 
     // Helpers locais para envio de mensagens (com credenciais do bot se dispon√≠veis)
     const sendMessage = (to, msg) => whatsappService.sendMessage(to, msg, zapiCredentials);
     const sendImage = (to, img, caption) => whatsappService.sendImage(to, img, caption, zapiCredentials);
     const sendButtons = (to, msg, btns) => whatsappService.sendButtons(to, msg, btns, zapiCredentials);
 
-    if (!payzuToken) {
+    if (!platformToken) {
         const tenant = tenantService.getTenantByPhone(phoneNumber);
         if (tenant && tenant.active) {
-            payzuToken = tenant.payzuToken;
+            platformToken = tenant.platformToken;
             myPixKey = tenant.myPixKey;
             contactsOwnerId = tenant.id; // Usar ID do tenant para contatos
             console.log(`   üè¢ Usando token do cliente: ${tenant.name}`);
         } else {
-            payzuToken = PAYZU_TOKEN;
+            platformToken = CREDPIX_TOKEN;
             myPixKey = process.env.MY_PIX_KEY;
             contactsOwnerId = phoneNumber; // Modo legado: usar phone
             console.log(`   Usando token do .env`);
         }
     } else if (!contactsOwnerId) {
-        // Se tem payzuToken mas n√£o tem contactsOwnerId, usar phone
+        // Se tem platformToken mas n√£o tem contactsOwnerId, usar phone
         contactsOwnerId = phoneNumber;
     }
 
-    if (!payzuToken) {
-        console.error('Nenhum token PayZu dispon√≠vel!');
-        await sendMsg(phoneNumber, 'Erro de configura√ß√£o. Contate o administrador.');
-        return;
-    }
-
     try {
         switch (command.action) {
             case 'generate_pix':
-                // Gerar PIX - PayZu usa valores em REAIS (n√£o centavos)
+                // Gerar PIX - CREDPIX usa valores em REAIS (n√£o centavos)
                 const amountInReais = (command.amount / 100).toFixed(2);
-                const tempScriptPixIn = `/tmp/pix_${Date.now()}.sh`;
-                const callbackUrl = `${BASE_URL}/webhook/payzu`;
-                const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/pix' \\
---header 'Content-Type: application/json' \\
---header 'Authorization: Bearer ${payzuToken}' \\
---data '{
-    "amount": ${amountInReais},
-    "callbackUrl": "${callbackUrl}",
-    "expiresIn": 86400
-  }' \\
--s -w '\\n__HTTP_STATUS__:%{http_code}'`;
-
-                fs.writeFileSync(tempScriptPixIn, scriptContent, { mode: 0o755 });
-                const pixOutputRaw = execSync(`bash ${tempScriptPixIn}`, { encoding: 'utf-8' });
-                fs.unlinkSync(tempScriptPixIn);
-
-                // Separar body e status code
-                const pixParts = pixOutputRaw.split('__HTTP_STATUS__:');
-                const pixBody = pixParts[0].trim();
-                const pixHttpStatus = pixParts[1] ? pixParts[1].trim() : 'unknown';
-
-                // DEBUG
-                console.log('\nüîç DEBUG - Resposta do PIX:');
-                console.log('URL:', `${PAYZU_BASE_URL}/pix`);
-                console.log('HTTP Status:', pixHttpStatus);
-                console.log('Body:', pixBody.substring(0, 500));
-
-                // Verificar erro HTTP
-                if (pixHttpStatus !== '200' && pixHttpStatus !== '201') {
-                    console.error('Erro HTTP na API PayZu:', pixHttpStatus);
-                    let pixErrorMsg = '';
-                    switch (pixHttpStatus) {
-                        case '401':
-                            pixErrorMsg = 'üîê Token inv√°lido ou expirado.';
-                            break;
-                        case '403':
-                            pixErrorMsg = 'üö´ Acesso negado.';
-                            break;
-                        case '502':
-                            pixErrorMsg = 'üîß Servidor PayZu indispon√≠vel (502). Tente novamente.';
-                            break;
-                        default:
-                            pixErrorMsg = `Erro na API (HTTP ${pixHttpStatus}).`;
-                    }
-                    await sendMessage(phoneNumber, `Erro ao gerar PIX:\n\n${pixErrorMsg}`);
-                    break;
-                }
+                const identifier = transactionsService.generateClientReference();
+                const copiaECola = `CREDPIX-${identifier}`;
+                const user = await getUserByChatId(phoneNumber);
 
-                // Verificar se √© JSON
-                if (!pixBody || pixBody.startsWith('<')) {
-                    console.error('Resposta n√£o √© JSON:', pixBody.substring(0, 200));
-                    await sendMessage(phoneNumber, 'Erro ao gerar PIX:\n\nüîß Resposta inv√°lida do servidor.');
-                    break;
-                }
-
-                try {
-                    const pixData = JSON.parse(pixBody);
-
-                    // PayZu retorna id e status diretamente (sem campo "success")
-                    if (pixData.id && pixData.status === 'PENDING') {
-                        const copiaECola = pixData.qrCodeText || '';
-
-                        // Registrar transa√ß√£o para receber webhook de confirma√ß√£o
-                        transactionsService.registerTransaction(
-                            pixData.id,
-                            phoneNumber,
-                            'pix_in',
-                            command.amount,
-                            { qrCodeText: copiaECola, botId }
-                        );
+                await transactionsService.registerTransaction(
+                    identifier,
+                    phoneNumber,
+                    'pix_in',
+                    command.amount,
+                    {
+                        brCode: copiaECola,
+                        tokenuser: user?.user_token || platformToken || null,
+                        botId
+                    }
+                );
 
-                        // Salvar c√≥digo PIX para bot√£o "copiar c√≥digo"
-                        lastGeneratedPixCodes.set(phoneNumber, {
-                            pixCode: copiaECola,
-                            amount: parseFloat(pixData.amount),
-                            timestamp: Date.now()
-                        });
+                // Salvar c√≥digo PIX para bot√£o "copiar c√≥digo"
+                lastGeneratedPixCodes.set(phoneNumber, {
+                    pixCode: copiaECola,
+                    amount: parseFloat(amountInReais),
+                    timestamp: Date.now()
+                });
 
-                        // Mensagem 1: Informa√ß√µes do PIX
-                        const infoMessage = `*PIX Gerado para Receber!*\n\n` +
-                            `Valor: *R$ ${parseFloat(pixData.amount).toFixed(2)}*\n` +
-                            `‚è∞ Expira em: 24 horas\n\n` +
-                            `*C√≥digo Copia e Cola:*`;
+                // Mensagem 1: Informa√ß√µes do PIX
+                const infoMessage = `*PIX Gerado para Receber!*\n\n` +
+                    `Valor: *R$ ${parseFloat(amountInReais).toFixed(2)}*\n` +
+                    `‚è∞ Expira em: 24 horas\n\n` +
+                    `*C√≥digo Copia e Cola:*`;
 
-                        await sendMessage(phoneNumber, infoMessage);
+                await sendMessage(phoneNumber, infoMessage);
 
-                        // Mensagem 2: S√≥ o c√≥digo copia e cola (f√°cil de copiar)
-                        await sendMessage(phoneNumber, copiaECola);
+                // Mensagem 2: S√≥ o c√≥digo copia e cola (f√°cil de copiar)
+                await sendMessage(phoneNumber, copiaECola);
 
-                        // Mensagem 3: Instru√ß√µes (sem bot√£o - WhatsApp n√£o tem "copiar para √°rea de transfer√™ncia")
-                        await sendMessage(phoneNumber,
-                            `*Copie o c√≥digo acima*\n\n` +
-                            `Abra o app do banco de quem vai pagar\n` +
-                            `Escolha "Pagar com PIX" ‚Üí "Copia e Cola"\n` +
-                            `Cole o c√≥digo e confirme\n\n` +
-                            `Voc√™ ser√° notificado quando o pagamento for confirmado!`);
-                    } else {
-                        const errorMsg = pixData.message || pixData.error || 'Erro desconhecido';
-                        await sendMessage(phoneNumber, `Erro ao gerar PIX: ${errorMsg}`);
-                    }
-                } catch (parseError) {
-                    console.error('Erro ao fazer parse:', parseError.message);
-                    await sendMessage(phoneNumber, 'Erro ao gerar PIX:\n\nüîß Resposta inv√°lida.');
-                }
+                // Mensagem 3: Instru√ß√µes (sem bot√£o - WhatsApp n√£o tem "copiar para √°rea de transfer√™ncia")
+                await sendMessage(phoneNumber,
+                    `*Copie o c√≥digo acima*\n\n` +
+                    `Abra o app do banco de quem vai pagar\n` +
+                    `Escolha "Pagar com PIX" ‚Üí "Copia e Cola"\n` +
+                    `Cole o c√≥digo e confirme\n\n` +
+                    `Voc√™ ser√° notificado quando o pagamento for confirmado!`);
                 break;
 
             case 'withdraw':
-                // Processar saque/transfer√™ncia PIX - PayZu usa valores em REAIS
+                // Processar saque/transfer√™ncia PIX - CREDPIX usa valores em REAIS
                 // LIMITE: R$ 10.000,00 por transa√ß√£o - dividir automaticamente
                 const LIMITE_POR_TRANSACAO = 1000000; // R$ 10.000,00 em centavos
                 const totalCentavos = command.amount;
                 const totalReais = (totalCentavos / 100).toFixed(2);
 
-                // Converter tipo de chave para min√∫sculas (PayZu)
+                // Converter tipo de chave para min√∫sculas (CREDPIX)
                 let pixKeyType = command.pixKeyType.toLowerCase();
                 if (pixKeyType === 'random') pixKeyType = 'evp';
 
                 // Tratar "cpf_or_phone" - validar CPF para decidir automaticamente
                 let pixKey = command.pixKey;
                 if (pixKeyType === 'cpf_or_phone') {
                     const digitsOnly = pixKey.replace(/\D/g, '');
                     if (digitsOnly.length === 11) {
                         if (isValidCPF(digitsOnly)) {
                             // CPF v√°lido - precisa perguntar ao usu√°rio
                             console.log(`üîç Chave ${digitsOnly}: CPF V√ÅLIDO - perguntando ao usu√°rio`);
 
                             // Salvar para confirma√ß√£o
                             pendingCPFConfirmations.set(phoneNumber, {
                                 command: { ...command, pixKey: digitsOnly },
                                 timestamp: Date.now()
                             });
 
                             await sendButtons(phoneNumber,
                                 `üîç *Confirma√ß√£o necess√°ria*\n\n` +
                                 `A chave *${digitsOnly}* pode ser CPF ou telefone.`,
                                 [
                                     { id: 'cpf', label: 'CPF' },
                                     { id: 'telefone', label: 'Telefone' },
                                     { id: 'cancelar', label: '‚ùå Cancelar' }
@@ -1669,317 +1651,194 @@ curl --location '${PAYZU_BASE_URL}/pix' \\
                 const numTransacoesCompletas = Math.floor(totalCentavos / LIMITE_POR_TRANSACAO);
                 const valorRestante = totalCentavos % LIMITE_POR_TRANSACAO;
 
                 // Montar lista de transa√ß√µes
                 const transacoes = [];
                 for (let i = 0; i < numTransacoesCompletas; i++) {
                     transacoes.push(LIMITE_POR_TRANSACAO); // R$ 10.000,00
                 }
                 if (valorRestante > 0) {
                     transacoes.push(valorRestante);
                 }
 
                 // Gerar clientReference √∫nico para o grupo
                 const clientReference = transactionsService.generateClientReference();
 
                 // Se houver m√∫ltiplas transa√ß√µes, criar grupo
                 let groupId = null;
                 if (transacoes.length > 1) {
                     groupId = clientReference;
                     transactionsService.createTransferGroup(groupId, phoneNumber, totalCentavos, transacoes.length, {
                         pixKey,
                         pixKeyType
                     });
                 }
 
-                console.log('\nDADOS DO SAQUE (PayZu):');
+                console.log('\nDADOS DO SAQUE (CREDPIX):');
                 console.log('   Total (centavos):', totalCentavos);
                 console.log('   Total (reais):', totalReais);
                 console.log('   PIX Key:', pixKey);
                 console.log('   PIX Key Type:', pixKeyType);
                 console.log('   Transa√ß√µes necess√°rias:', transacoes.length);
                 console.log('   Valores:', transacoes.map(v => `R$ ${(v/100).toFixed(2)}`).join(', '));
 
                 // Informar usu√°rio sobre m√∫ltiplas transa√ß√µes
                 if (transacoes.length > 1) {
                     let resumo = `*Resumo do Envio*\n\n`;
                     resumo += `Valor total: *R$ ${totalReais}*\n`;
                     resumo += `üì¶ Transa√ß√µes: ${transacoes.length}\n\n`;
 
                     // Agrupar transa√ß√µes iguais
                     const grupos = {};
                     transacoes.forEach(v => {
                         grupos[v] = (grupos[v] || 0) + 1;
                     });
 
                     Object.entries(grupos).forEach(([valor, qtd]) => {
                         resumo += `‚Ä¢ ${qtd}x de R$ ${(valor/100).toFixed(2)}\n`;
                     });
 
                     resumo += `\n‚è≥ Processando...`;
                     await sendMessage(phoneNumber, resumo);
                 }
 
                 // Executar cada transa√ß√£o
                 let sucessos = 0;
                 let falhas = 0;
                 const resultados = [];
+                const user = await getUserByChatId(phoneNumber);
 
                 for (let i = 0; i < transacoes.length; i++) {
                     const valorTransacao = transacoes[i];
                     const valorReais = (valorTransacao / 100).toFixed(2);
 
-                    console.log(`\nExecutando transa√ß√£o ${i + 1}/${transacoes.length}: R$ ${valorReais}`);
+                    console.log(`\nRegistrando transa√ß√£o ${i + 1}/${transacoes.length}: R$ ${valorReais}`);
 
-                    const tempScriptWithdraw = `/tmp/withdraw_${Date.now()}_${i}.sh`;
-                    const withdrawCallbackUrl = `${BASE_URL}/webhook/payzu`;
                     // clientReference √∫nico: groupId + √≠ndice (ou s√≥ clientReference se transa√ß√£o √∫nica)
                     const txClientRef = groupId ? `${clientReference}_${i}` : clientReference;
-                    const withdrawScript = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/withdraw' \\
---header 'Content-Type: application/json' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${payzuToken}' \\
---data '{
-    "amount": ${valorReais},
-    "pixKey": "${pixKey}",
-    "pixType": "${pixKeyType}",
-    "clientReference": "${txClientRef}",
-    "callbackUrl": "${withdrawCallbackUrl}"
-}' \\
--s -w '\\n__HTTP_STATUS__:%{http_code}'`;
-
-                    fs.writeFileSync(tempScriptWithdraw, withdrawScript, { mode: 0o755 });
 
                     try {
-                        const withdrawOutputRaw = execSync(`bash ${tempScriptWithdraw}`, { encoding: 'utf-8' });
-                        fs.unlinkSync(tempScriptWithdraw);
-
-                        const withdrawParts = withdrawOutputRaw.split('__HTTP_STATUS__:');
-                        const withdrawBody = withdrawParts[0].trim();
-                        const withdrawHttpStatus = withdrawParts[1] ? withdrawParts[1].trim() : 'unknown';
-
-                        console.log(`   HTTP Status: ${withdrawHttpStatus}`);
-                        console.log(`   Body completo:`, withdrawBody);
-
-                        if (withdrawHttpStatus === '200' || withdrawHttpStatus === '201') {
-                            const withdrawData = JSON.parse(withdrawBody);
-                            if (withdrawData.id) {
-                                sucessos++;
-
-                                // Capturar nome do destinat√°rio se dispon√≠vel
-                                const receiverName = withdrawData.receiverName ||
-                                                    withdrawData.payeeName ||
-                                                    withdrawData.beneficiaryName ||
-                                                    withdrawData.holderName ||
-                                                    withdrawData.name ||
-                                                    null;
-
-                                resultados.push({
-                                    valor: valorReais,
-                                    status: 'ok',
-                                    id: withdrawData.id,
-                                    receiverName: receiverName
-                                });
-
-                                console.log(`   Sucesso! ID: ${withdrawData.id}`);
-                                if (receiverName) {
-                                    console.log(`   Destinat√°rio: ${receiverName}`);
-                                }
-
-                                // Registrar transa√ß√£o para receber webhook de confirma√ß√£o
-                                transactionsService.registerTransaction(
-                                    withdrawData.id,
-                                    phoneNumber,
-                                    'pix_out',
-                                    valorTransacao,
-                                    { pixKey, pixKeyType, receiverName, groupId, clientReference: txClientRef, botId }
-                                );
-
-                                // Se faz parte de um grupo, adicionar ao grupo
-                                if (groupId) {
-                                    transactionsService.addTransactionToGroup(groupId, withdrawData.id);
-                                }
-                            } else {
-                                falhas++;
-                                resultados.push({ valor: valorReais, status: 'erro', msg: withdrawData.message || 'Erro desconhecido' });
-                                // Marcar falha imediata no grupo (para n√£o ficar esperando webhook)
-                                if (groupId) {
-                                    transactionsService.markGroupTransactionFailed(groupId, valorTransacao, null);
-                                }
-                            }
-                        } else {
-                            falhas++;
-                            let errorMsg = 'Erro HTTP ' + withdrawHttpStatus;
-                            try {
-                                const errData = JSON.parse(withdrawBody);
-                                errorMsg = errData.message || errorMsg;
-                            } catch (e) {}
-                            resultados.push({ valor: valorReais, status: 'erro', msg: errorMsg });
-                            console.log(`   Falha: ${errorMsg}`);
-                            // Marcar falha imediata no grupo (para n√£o ficar esperando webhook)
-                            if (groupId) {
-                                transactionsService.markGroupTransactionFailed(groupId, valorTransacao, null);
+                        await transactionsService.registerTransaction(
+                            txClientRef,
+                            phoneNumber,
+                            'pix_out',
+                            valorTransacao,
+                            {
+                                pixKey,
+                                pixKeyType,
+                                receiverName: command.receiverName || null,
+                                groupId,
+                                clientReference: txClientRef,
+                                tokenuser: user?.user_token || platformToken || null,
+                                botId
                             }
+                        );
+
+                        sucessos++;
+                        resultados.push({
+                            valor: valorReais,
+                            status: 'ok',
+                            id: txClientRef,
+                            receiverName: command.receiverName || null
+                        });
+
+                        if (groupId) {
+                            transactionsService.addTransactionToGroup(groupId, txClientRef);
                         }
-                    } catch (execError) {
+                    } catch (error) {
                         falhas++;
-                        resultados.push({ valor: valorReais, status: 'erro', msg: execError.message });
-                        console.error(`   Erro de execu√ß√£o: ${execError.message}`);
-                        try { fs.unlinkSync(tempScriptWithdraw); } catch (e) {}
-                        // Marcar falha imediata no grupo (para n√£o ficar esperando webhook)
+                        resultados.push({ valor: valorReais, status: 'erro', msg: error.message });
+                        console.error(`   Erro de registro: ${error.message}`);
                         if (groupId) {
-                            transactionsService.markGroupTransactionFailed(groupId, valorTransacao, null);
+                            transactionsService.markGroupTransactionFailed(groupId, valorTransacao, txClientRef);
                         }
                     }
 
-                    // Pequeno delay entre transa√ß√µes para n√£o sobrecarregar
                     if (i < transacoes.length - 1) {
-                        await new Promise(resolve => setTimeout(resolve, 500));
+                        await new Promise(resolve => setTimeout(resolve, 200));
                     }
                 }
 
                 // Enviar resultado final
                 let resultMessage = '';
                 if (falhas === 0) {
                     resultMessage = `‚è≥ *PIX em Processamento*\n\n`;
                     resultMessage += `Valor total: *R$ ${totalReais}*\n`;
                     // Mostrar nome do destinat√°rio se dispon√≠vel
                     if (resultados[0]?.receiverName) {
                         resultMessage += `Destinat√°rio: *${resultados[0].receiverName}*\n`;
                     }
                     resultMessage += `Chave: ${pixKey}\n`;
                     resultMessage += `üì¶ Transa√ß√µes: ${sucessos}\n\n`;
                     resultMessage += `Voc√™ ser√° notificado quando for confirmado!`;
                 } else if (sucessos === 0) {
                     resultMessage = `*Erro ao enviar PIX*\n\n`;
                     resultMessage += `Nenhuma transa√ß√£o foi processada.\n`;
                     resultMessage += `Erro: ${resultados[0]?.msg || 'Desconhecido'}`;
                 } else {
                     // Calcular valor real enviado (sucesso) e valor que falhou
                     const valorEnviado = resultados
                         .filter(r => r.status === 'ok')
                         .reduce((sum, r) => sum + parseFloat(r.valor), 0);
                     const valorFalhou = resultados
                         .filter(r => r.status === 'erro')
                         .reduce((sum, r) => sum + parseFloat(r.valor), 0);
 
                     resultMessage = `*PIX Parcialmente Processado*\n\n`;
                     // Mostrar nome do destinat√°rio se dispon√≠vel
                     if (resultados.find(r => r.receiverName)?.receiverName) {
                         resultMessage += `Destinat√°rio: *${resultados.find(r => r.receiverName).receiverName}*\n`;
                     }
                     resultMessage += `Em processamento: ${sucessos} PIX (R$ ${valorEnviado.toFixed(2)})\n`;
                     resultMessage += `Falhou: ${falhas} PIX (R$ ${valorFalhou.toFixed(2)})\n\n`;
                     resultMessage += `üí° _O valor que falhou permanece na sua conta._\n`;
                     resultMessage += `Voc√™ receber√° o comprovante quando as transa√ß√µes forem confirmadas.`;
                 }
 
                 await sendMessage(phoneNumber, resultMessage);
                 break;
 
             case 'check_balance':
-                // Consultar saldo - PayZu retorna valores em REAIS
-                const tempScriptBalance = `/tmp/balance_${Date.now()}.sh`;
-                // Adiciona -w para capturar HTTP status code
-                const balanceScript = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/user/balance' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${payzuToken}' \\
--s -w '\\n__HTTP_STATUS__:%{http_code}'`;
-
-                fs.writeFileSync(tempScriptBalance, balanceScript, { mode: 0o755 });
-                const balanceOutputRaw = execSync(`bash ${tempScriptBalance}`, { encoding: 'utf-8' });
-                fs.unlinkSync(tempScriptBalance);
-
-                // Separar body e status code
-                const balanceParts = balanceOutputRaw.split('__HTTP_STATUS__:');
-                const balanceBody = balanceParts[0].trim();
-                const balanceHttpStatus = balanceParts[1] ? balanceParts[1].trim() : 'unknown';
-
-                // DEBUG: Ver resposta raw da API
-                console.log('\nüîç DEBUG - Resposta do balance:');
-                console.log('URL:', `${PAYZU_BASE_URL}/user/balance`);
-                console.log('HTTP Status:', balanceHttpStatus);
-                console.log('Body (primeiros 500 chars):', balanceBody.substring(0, 500));
-
-                // Verificar se houve erro HTTP
-                if (balanceHttpStatus !== '200') {
-                    console.error('Erro HTTP na API PayZu:', balanceHttpStatus);
-                    let errorMsg = '';
-                    switch (balanceHttpStatus) {
-                        case '401':
-                            errorMsg = 'üîê Token inv√°lido ou expirado. Contate o administrador.';
-                            break;
-                        case '403':
-                            errorMsg = 'üö´ Acesso negado. Verifique permiss√µes do token.';
-                            break;
-                        case '502':
-                            errorMsg = 'üîß Servidor PayZu indispon√≠vel (502). Tente novamente em alguns minutos.';
-                            break;
-                        case '503':
-                            errorMsg = 'üîß Servidor PayZu em manuten√ß√£o (503). Tente mais tarde.';
-                            break;
-                        default:
-                            errorMsg = `Erro na API PayZu (HTTP ${balanceHttpStatus}). Tente novamente.`;
-                    }
-                    await sendMessage(phoneNumber, `Erro ao consultar saldo:\n\n${errorMsg}`);
-                    break;
-                }
-
-                // Verificar se resposta √© JSON v√°lido
-                if (!balanceBody || balanceBody.startsWith('<') || balanceBody.startsWith('<!')) {
-                    console.error('Resposta n√£o √© JSON:', balanceBody.substring(0, 200));
+                // Consultar saldo na CREDPIX (banco de dados)
+                const userBalance = await getUserByChatId(phoneNumber);
+                if (!userBalance) {
                     await sendMessage(phoneNumber,
-                        'Erro ao consultar saldo:\n\nüîß Servidor retornou resposta inv√°lida. Tente novamente.');
+                        'N√£o encontrei seu cadastro na CREDPIX.\n' +
+                        'Pe√ßa ao administrador para cadastrar seu n√∫mero.');
                     break;
                 }
 
-                try {
-                    const balanceData = JSON.parse(balanceBody);
-
-                    // Verificar se h√° erro na resposta JSON
-                    if (balanceData.error || balanceData.message) {
-                        const apiError = balanceData.message || balanceData.error;
-                        console.error('Erro retornado pela API:', apiError);
-                        await sendMessage(phoneNumber, `Erro ao consultar saldo:\n\n${apiError}`);
-                        break;
-                    }
+                const saldoDisponivel = parseFloat(userBalance.saldo || 0);
+                const saldoBloqueado = parseFloat(userBalance.reservado || 0);
+                const saldoSaque = parseFloat(userBalance.limite_saque || saldoDisponivel);
 
-                    // PayZu retorna: balanceAvailable, balanceBlocked, balanceAvailableWithdraw (em reais)
-                    const balanceMessage = `*Seu saldo:*\n\n` +
-                        `Dispon√≠vel: R$ ${formatBRL(balanceData.balanceAvailable || 0)}\n` +
-                        `Bloqueado: R$ ${formatBRL(balanceData.balanceBlocked || 0)}\n` +
-                        `Para saque: R$ ${formatBRL(balanceData.balanceAvailableWithdraw || 0)}`;
+                const balanceMessage = `*Seu saldo:*\n\n` +
+                    `Dispon√≠vel: R$ ${formatBRL(saldoDisponivel)}\n` +
+                    `Bloqueado: R$ ${formatBRL(saldoBloqueado)}\n` +
+                    `Para saque: R$ ${formatBRL(saldoSaque)}`;
 
-                    await sendMessage(phoneNumber, balanceMessage);
-                } catch (parseError) {
-                    console.error('Erro ao fazer parse do JSON:', parseError.message);
-                    console.error('Body recebido:', balanceBody.substring(0, 300));
-                    await sendMessage(phoneNumber,
-                        'Erro ao consultar saldo:\n\nüîß Resposta inv√°lida do servidor. Tente novamente.');
-                }
+                await sendMessage(phoneNumber, balanceMessage);
                 break;
 
             case 'my_pix_key':
                 // Mostrar chave PIX do usu√°rio - DUAS MENSAGENS SEPARADAS
                 const userPixKey = myPixKey || 'Chave n√£o configurada';
 
                 // Mensagem 1: S√≥ a chave
                 await sendMessage(phoneNumber, userPixKey);
 
                 // Mensagem 2: Informa√ß√µes extras
                 await sendMessage(phoneNumber,
                     `Compartilhe para receber pagamentos!\nüí° Esta √© sua chave aleat√≥ria`);
                 break;
 
             // ========== GERENCIAMENTO DE CONTATOS ==========
 
             case 'save_contact':
                 // Salvar novo contato
                 try {
                     const savedContact = contactsService.addContact(
                         contactsOwnerId,
                         command.name,
                         command.pixKey,
                         command.pixKeyType
                     );
@@ -2064,51 +1923,51 @@ curl --location '${PAYZU_BASE_URL}/user/balance' \\
                     `üìí Enviando para *${contact.name}*...\n` +
                     `${contact.pixKey}`);
 
                 // Executar o withdraw recursivamente (passando mesmo contactsOwnerId)
                 await executePixCommand(contactCommand, phoneNumber, { contactsOwnerId, zapiCredentials, botBranding, botId });
                 return; // Importante: retornar para n√£o executar o default
 
             case 'ask':
                 // IA est√° fazendo uma pergunta ao usu√°rio
                 const question = aiService.generateResponse(command);
                 await sendMessage(phoneNumber, question);
                 break;
 
             // ========== ESTORNO DE PIX ==========
 
             case 'search_refund':
                 // Buscar PIX para estorno por valor
                 try {
                     const searchAmount = command.amount; // valor do PIX em centavos (ou null para buscar √∫ltimos)
                     const refundAmount = command.refundAmount; // valor a estornar em centavos (estorno parcial)
 
                     // Se tem refundAmount, √© estorno parcial - mostrar √∫ltimos PIX
                     const effectiveSearchAmount = refundAmount && !searchAmount ? null : searchAmount;
 
                     // Buscar transa√ß√µes que podem ser estornadas
-                    const refundable = transactionsService.findRefundableTransactions(phoneNumber, effectiveSearchAmount, 5);
+                    const refundable = await transactionsService.findRefundableTransactions(phoneNumber, effectiveSearchAmount, 5);
 
                     if (refundable.length === 0) {
                         let notFoundMsg = `*Nenhum PIX encontrado para estorno*\n\n`;
                         if (searchAmount) {
                             notFoundMsg += `N√£o encontrei nenhum PIX recebido de R$ ${(searchAmount / 100).toFixed(2)} que possa ser estornado.\n\n`;
                         } else {
                             notFoundMsg += `N√£o encontrei PIX recebidos que possam ser estornados.\n\n`;
                         }
                         notFoundMsg += `üìå _Lembre-se: s√≥ √© poss√≠vel estornar PIX recebidos (dep√≥sitos) que ainda n√£o foram estornados._`;
                         await sendMessage(phoneNumber, notFoundMsg);
                         break;
                     }
 
                     // Formatar valor do estorno parcial se existir
                     const refundAmountStr = refundAmount ? `R$ ${(refundAmount / 100).toFixed(2)}` : null;
 
                     if (refundable.length === 1) {
                         // Encontrou exatamente 1 - pedir confirma√ß√£o
                         const tx = refundable[0];
                         const valor = (tx.amount / 100).toFixed(2);
                         const data = new Date(tx.createdAt).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });
 
                         // Salvar para confirma√ß√£o (incluindo valor parcial se existir)
                         pendingRefundConfirmations.set(phoneNumber, {
                             transaction: tx,
@@ -2157,608 +2016,324 @@ curl --location '${PAYZU_BASE_URL}/user/balance' \\
                             await sendButtons(phoneNumber, listMsg, [
                                 { id: 'sim', label: refundAmount ? 'Estornar parcial' : 'Sim, estornar' },
                                 { id: 'nao', label: '‚ùå Cancelar' }
                             ]);
                         } else {
                             listMsg += `üí° _Responda com o n√∫mero (1, 2, 3...) do PIX que deseja estornar._`;
 
                             // Salvar lista para sele√ß√£o
                             pendingRefundConfirmations.set(phoneNumber, {
                                 transactionList: refundable,
                                 refundAmount: refundAmount || null,
                                 timestamp: Date.now()
                             });
 
                             await sendMessage(phoneNumber, listMsg);
                         }
                     }
                 } catch (searchError) {
                     console.error('Erro ao buscar PIX para estorno:', searchError.message);
                     await sendMessage(phoneNumber,
                         `Erro ao buscar transa√ß√µes: ${searchError.message}`);
                 }
                 break;
 
             case 'refund':
-                // Estornar um PIX recebido (devolu√ß√£o)
+                // Estornar um PIX recebido (registro na CREDPIX)
                 try {
                     const transactionId = command.transactionId;
-                    const endToEndId = command.endToEndId;
                     const reason = command.reason || 'Devolu√ß√£o solicitada pelo cliente';
 
-                    if (!transactionId && !endToEndId) {
+                    if (!transactionId) {
                         await sendMessage(phoneNumber,
                             `*ID do PIX n√£o informado*\n\n` +
                             `Para estornar um PIX, preciso do ID da transa√ß√£o.\n\n` +
-                            `Voc√™ pode encontrar o ID:\n` +
-                            `‚Ä¢ No comprovante do PIX recebido\n` +
-                            `‚Ä¢ Come√ßa com "PAYZU..." ou "E..."` );
+                            `Voc√™ pode encontrar o ID no comprovante do PIX recebido.`);
                         break;
                     }
 
-                    // Verificar se √© estorno parcial
-                    const partialRefundAmount = command.refundAmount; // em centavos
+                    const partialRefundAmount = command.refundAmount;
                     if (partialRefundAmount) {
                         const partialReais = (partialRefundAmount / 100).toFixed(2);
-                        await sendMessage(phoneNumber, `‚è≥ Processando estorno parcial de R$ ${partialReais}...`);
+                        await sendMessage(phoneNumber, `‚è≥ Registrando estorno parcial de R$ ${partialReais}...`);
                     } else {
-                        await sendMessage(phoneNumber, '‚è≥ Processando estorno...');
+                        await sendMessage(phoneNumber, '‚è≥ Registrando estorno...');
                     }
 
-                    // Montar body do request
-                    const refundBody = {};
-                    if (transactionId) refundBody.id = transactionId;
-                    if (endToEndId) refundBody.endToEndId = endToEndId;
-                    refundBody.description = reason;
-                    refundBody.callbackUrl = `${BASE_URL}/webhook/payzu`;
-
-                    // Se for estorno parcial, enviar o valor em REAIS (API PayZu usa reais)
-                    // Documenta√ß√£o PayZu n√£o especifica campo - testando 'value' (padr√£o comum)
-                    if (partialRefundAmount) {
-                        const partialValueReais = partialRefundAmount / 100;
-                        refundBody.value = partialValueReais; // Testar com 'value'
-                        refundBody.amount = partialValueReais; // Manter 'amount' tamb√©m por seguran√ßa
-                        console.log(`Estorno PARCIAL: R$ ${partialValueReais.toFixed(2)}`);
-                        console.log(`üì¶ Body do estorno:`, JSON.stringify(refundBody));
-                    }
-
-                    // Usar endpoint POST /pix/refund (conforme documenta√ß√£o PayZu)
-                    const refundUrl = `${PAYZU_BASE_URL}/pix/refund`;
-
-                    const tempScriptRefund = `/tmp/refund_${Date.now()}.sh`;
-                    const refundScript = `#!/bin/bash
-curl --location --request POST '${refundUrl}' \\
---header 'Content-Type: application/json' \\
---header 'Authorization: Bearer ${payzuToken}' \\
---data '${JSON.stringify(refundBody)}' \\
--s`;
-
-                    fs.writeFileSync(tempScriptRefund, refundScript, { mode: 0o755 });
-                    console.log('üìú Script de estorno criado:', tempScriptRefund);
-                    console.log('URL:', refundUrl);
-                    console.log('M√©todo: POST');
-                    console.log('Body:', JSON.stringify(refundBody, null, 2));
-
-                    const refundResult = execSync(`bash ${tempScriptRefund}`, {
-                        encoding: 'utf-8',
-                        timeout: 30000
-                    });
-
-                    // Limpar script tempor√°rio
-                    try { fs.unlinkSync(tempScriptRefund); } catch (e) { }
-
-                    console.log('üì¶ Resposta PayZu (Estorno) COMPLETA:', refundResult);
-
-                    // Parse da resposta
-                    const refundData = JSON.parse(refundResult);
-
-                    if (refundData.error || refundData.statusCode >= 400) {
-                        throw new Error(refundData.message || refundData.error || 'Erro ao processar estorno');
-                    }
-
-                    // Validar e extrair valor do estorno - priorizar refundAmount para estornos parciais
-                    let refundAmount = null;
-                    const originalAmount = refundData.amount || refundData.originalAmount;
-
-                    // Tentar extrair o valor do estorno de v√°rios campos poss√≠veis
-                    if (refundData.refundAmount !== undefined && refundData.refundAmount !== null) {
-                        refundAmount = parseFloat(refundData.refundAmount);
-                        console.log(`Valor do estorno (refundAmount): R$ ${refundAmount}`);
-                    } else if (refundData.returnedAmount !== undefined && refundData.returnedAmount !== null) {
-                        refundAmount = parseFloat(refundData.returnedAmount);
-                        console.log(`Valor do estorno (returnedAmount): R$ ${refundAmount}`);
-                    } else if (refundData.value !== undefined && refundData.value !== null) {
-                        refundAmount = parseFloat(refundData.value);
-                        console.log(`Valor do estorno (value): R$ ${refundAmount}`);
-                    } else if (originalAmount !== undefined && originalAmount !== null) {
-                        refundAmount = parseFloat(originalAmount);
-                        console.log(`Valor do estorno (amount/originalAmount): R$ ${refundAmount}`);
-                    }
-
-                    // Verificar se √© estorno parcial
-                    const isPartialRefund = originalAmount && refundAmount &&
-                        parseFloat(originalAmount) > refundAmount;
-
-                    if (isPartialRefund) {
-                        console.log(`ESTORNO PARCIAL: R$ ${refundAmount} de R$ ${originalAmount}`);
+                    const transaction = await transactionsService.getTransaction(transactionId);
+                    if (!transaction) {
+                        await sendMessage(phoneNumber,
+                            `Transa√ß√£o n√£o encontrada. Verifique se o ID est√° correto.`);
+                        break;
                     }
 
-                    const refundStatus = refundData.refundStatus || refundData.status;
+                    const refundAmountCents = partialRefundAmount || transaction.amount;
+                    const refundAmountReais = (refundAmountCents / 100).toFixed(2);
 
-                    console.log('Dados do estorno:', {
-                        refundAmount,
-                        originalAmount,
-                        isPartialRefund,
-                        status: refundStatus,
-                        id: refundData.id
+                    await transactionsService.updateTransaction(transactionId, 'REFUND_REQUESTED', {
+                        refundAmount: refundAmountReais,
+                        refundReason: reason
                     });
 
-                    // Marcar transa√ß√£o como estornada no registro local
-                    if (transactionId) {
-                        transactionsService.markAsRefunded(transactionId);
-                    }
+                    await transactionsService.markAsRefunded(transactionId);
 
-                    // Usar motivo da API se dispon√≠vel, sen√£o usar o informado pelo usu√°rio
-                    const finalReason = refundData.refundDescription || reason;
+                    let successMsg = `‚úÖ *Estorno solicitado com sucesso!*\n\n` +
+                        `Valor: *R$ ${formatBRL(refundAmountReais)}*`;
 
-                    // Gerar comprovante de estorno
-                    try {
-                        const receiptData = {
-                            type: 'refund',
-                            amount: refundAmount,
-                            originalAmount: isPartialRefund ? parseFloat(originalAmount) : null,
-                            isPartialRefund: isPartialRefund,
-                            transactionId: refundData.id || transactionId,
-                            refundReason: finalReason,
-                            refundEndToEndId: refundData.refundEndToEndId,
-                            // Dados do pagador original (quem recebeu e agora devolve)
-                            payerName: refundData.payerName || currentTenant?.name || 'N/A',
-                            payerDocument: refundData.payerDocument || '',
-                            payerBank: refundData.payerBank || 'PayZu',
-                            // Dados do recebedor (quem receber√° a devolu√ß√£o)
-                            receiverName: refundData.receiverName || refundData.payerName || 'N/A',
-                            receiverDocument: refundData.receiverDocument || refundData.payerDocument || '',
-                            receiverBank: refundData.receiverBank || refundData.payerBank || ''
-                        };
-
-                        const receiptBase64 = await receiptGenerator.generateReceiptBase64(receiptData, botBranding);
-
-                        // Montar legenda do comprovante
-                        let caption = `‚Ü©Ô∏è *ESTORNO CONFIRMADO*\n\n` +
-                            `Valor: R$ ${formatBRL(refundAmount)}`;
-
-                        if (isPartialRefund) {
-                            caption += ` _(de R$ ${formatBRL(originalAmount)})_`;
-                        }
-
-                        caption += `\nMotivo: ${finalReason}`;
-
-                        if (refundData.refundEndToEndId) {
-                            caption += `\nE2E: ${refundData.refundEndToEndId}`;
-                        }
-
-                        await sendImage(phoneNumber, receiptBase64, caption);
-                        console.log('Comprovante de estorno enviado');
-                    } catch (receiptError) {
-                        console.error('Erro ao gerar comprovante de estorno:', receiptError.message);
-                        // Se falhar o comprovante, enviar mensagem de texto
-                        let successMsg = `‚Ü©Ô∏è *ESTORNO CONFIRMADO*\n\n` +
-                            `Valor: *R$ ${formatBRL(refundAmount)}*`;
-
-                        if (isPartialRefund) {
-                            successMsg += ` _(de R$ ${formatBRL(originalAmount)})_`;
-                        }
-
-                        successMsg += `\nStatus: ${refundStatus}\n` +
-                            `ID: ${refundData.id}\n` +
-                            (refundData.refundEndToEndId ? `E2E: ${refundData.refundEndToEndId}\n` : '') +
-                            `\nMotivo: ${finalReason}\n\n` +
-                            `‚è≥ _O valor ser√° devolvido ao pagador._`;
-                        await sendMessage(phoneNumber, successMsg);
+                    if (partialRefundAmount) {
+                        successMsg += ` _(parcial)_`;
                     }
 
+                    successMsg += `\nMotivo: ${reason}\n` +
+                        `ID: ${transactionId}\n\n` +
+                        `‚è≥ _O estorno ser√° processado pela CREDPIX._`;
+
+                    await sendMessage(phoneNumber, successMsg);
                 } catch (refundError) {
                     console.error('Erro no estorno:', refundError.message);
-
-                    let errorMsg = `*Erro ao estornar PIX*\n\n`;
-
-                    if (refundError.message.includes('not found')) {
-                        errorMsg += `Transa√ß√£o n√£o encontrada.\nVerifique se o ID est√° correto.`;
-                    } else if (refundError.message.includes('already refunded')) {
-                        errorMsg += `Este PIX j√° foi estornado anteriormente.`;
-                    } else if (refundError.message.includes('expired')) {
-                        errorMsg += `Prazo para estorno expirado.\nPIX s√≥ pode ser estornado em at√© 90 dias.`;
-                    } else {
-                        errorMsg += `${refundError.message}`;
-                    }
-
-                    await sendMessage(phoneNumber, errorMsg);
+                    await sendMessage(phoneNumber,
+                        `*Erro ao estornar PIX*\n\n${refundError.message}`);
                 }
                 break;
 
             case 'help':
             case 'clarification_needed':
             case 'error':
             case 'unknown':
                 const helpMessage = aiService.generateResponse(command);
                 await sendMessage(phoneNumber, helpMessage);
                 break;
 
             default:
                 await sendMessage(
                     phoneNumber,
                     'Desculpe, n√£o consegui processar seu pedido. Digite "ajuda" para ver os comandos.'
                 );
         }
 
     } catch (error) {
         console.error('Erro ao executar comando:', error.message);
         await sendMessage(
             phoneNumber,
             `Erro ao processar: ${error.message}\n\nTente novamente ou digite "ajuda".`
         );
     }
 }
 
 // ========== ROTAS PIX ==========
 
-// Rota para PIX In (Dep√≥sito) - PayZu API
+// Rota para PIX In (Dep√≥sito) - CREDPIX
 app.post('/api/pix-in', async (req, res) => {
-    const tempScript = `/tmp/pix_${Date.now()}.sh`;
-
     try {
-        const { amount, postbackUrl } = req.body;
-        const callback = postbackUrl || 'https://tight-holiday-28.webhook.cool';
-        // PayZu usa valores em REAIS (n√£o centavos)
-        const amountInReais = (amount / 100).toFixed(2);
+        const { amount, chatid, phone, postbackUrl } = req.body;
+        const ownerChatId = chatid || phone;
 
-        console.log('\nüéØ GERANDO PIX REAL (PayZu) - Valor:', amount, 'centavos (R$', amountInReais, ')');
-
-        // Criar script tempor√°rio com comando curl para PayZu API
-        const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/pix' \\
---header 'Content-Type: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
---data '{
-    "callbackUrl": "'"${callback}"'",
-    "amount": '"${amountInReais}"',
-    "expiresIn": 86400
-  }' \\
--s`;
-
-        fs.writeFileSync(tempScript, scriptContent, { mode: 0o755 });
-
-        // Executar script
-        const output = execSync(`bash ${tempScript}`, { encoding: 'utf-8' });
-
-        // Limpar arquivo tempor√°rio
-        fs.unlinkSync(tempScript);
-
-        // Parse da resposta
-        const response = JSON.parse(output);
-
-        // PayZu retorna id e status diretamente
-        if (response.id && response.status) {
-            console.log('PIX REAL GERADO COM SUCESSO (PayZu)!');
-            console.log('   ID:', response.id);
-            console.log('   Status:', response.status);
-
-            // Normalizar resposta para o frontend (converter de volta para centavos)
-            const result = {
-                success: true,
-                id: response.id,
-                status: response.status,
-                amount: Math.round(parseFloat(response.amount) * 100), // Converter para centavos
-                expirationDate: response.createdAt,
-                pixCopiaECola: response.qrCodeText || '',
-                qrcode: response.qrCodeBase64 || '',
-                brcode: response.qrCodeText || ''
-            };
-
-            return res.json(result);
-        } else if (response.statusCode === 401) {
-            console.error('Erro 401: Token inv√°lido');
-            return res.status(401).json({
+        if (!ownerChatId || !amount) {
+            return res.status(400).json({
                 error: true,
-                message: 'Token inv√°lido. Por favor, atualize o PAYZU_TOKEN.',
-                details: response
+                message: 'Informe chatid (ou phone) e amount.'
             });
         }
 
-        // Se chegou aqui, algo deu errado
-        console.error('Erro ao gerar PIX:', response);
-        return res.status(400).json({
-            error: true,
-            message: response.message || response.error || 'Erro ao gerar PIX',
-            details: response
+        const amountInReais = (amount / 100).toFixed(2);
+        const identifier = transactionsService.generateClientReference();
+        const copiaECola = `CREDPIX-${identifier}`;
+        const user = await getUserByChatId(ownerChatId);
+
+        await transactionsService.registerTransaction(identifier, ownerChatId, 'pix_in', amount, {
+            brCode: copiaECola,
+            tokenuser: user?.user_token || CREDPIX_TOKEN || null,
+            callbackUrl: postbackUrl || null
         });
 
+        return res.json({
+            success: true,
+            id: identifier,
+            status: 'PENDING',
+            amount,
+            expirationDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
+            pixCopiaECola: copiaECola,
+            brcode: copiaECola
+        });
     } catch (error) {
-        // Limpar arquivo tempor√°rio em caso de erro
-        if (fs.existsSync(tempScript)) {
-            fs.unlinkSync(tempScript);
-        }
-
-        console.error('üí• Erro cr√≠tico:', error.message);
+        console.error('üí• Erro ao processar dep√≥sito:', error.message);
         res.status(500).json({
             error: true,
             message: 'Erro ao processar dep√≥sito',
             details: error.message
         });
     }
 });
 
-// Rota para PIX Out (Saque) - PayZu API
+// Rota para PIX Out (Saque) - CREDPIX
 app.post('/api/pix-out', async (req, res) => {
-    const tempScript = `/tmp/pix_out_${Date.now()}.sh`;
-
     try {
-        const { amount, pixKey, pixKeyType } = req.body;
-        // PayZu usa valores em REAIS (n√£o centavos)
-        const amountInReais = (amount / 100).toFixed(2);
-
-        // Converter tipo de chave para min√∫sculas (PayZu)
-        let payzuKeyType = pixKeyType.toLowerCase();
-        if (payzuKeyType === 'random') payzuKeyType = 'evp';
+        const { amount, pixKey, pixKeyType, chatid, phone } = req.body;
+        const ownerChatId = chatid || phone;
 
-        // Para telefone, garantir c√≥digo do pa√≠s (55)
-        let payzuPixKey = pixKey;
-        if (payzuKeyType === 'phone' && !payzuPixKey.startsWith('55')) {
-            payzuPixKey = '55' + payzuPixKey;
-        }
-
-        console.log('\nPROCESSANDO SAQUE REAL (PayZu)');
-        console.log('   Valor:', amount, 'centavos (R$', amountInReais, ')');
-        console.log('   Destino:', payzuKeyType, '-', payzuPixKey);
-
-        // Criar script tempor√°rio
-        const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/withdraw' \\
---header 'Content-Type: application/json' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
---data '{
-    "amount": '"${amountInReais}"',
-    "callbackUrl": "https://webhook.cool/at/bored-salesmen-91",
-    "pixKey": "'"${payzuPixKey}"'",
-    "pixType": "'"${payzuKeyType}"'"
-}' \\
--s`;
-
-        fs.writeFileSync(tempScript, scriptContent, { mode: 0o755 });
-
-        const output = execSync(`bash ${tempScript}`, { encoding: 'utf-8' });
-        fs.unlinkSync(tempScript);
-
-        const response = JSON.parse(output);
-
-        if (response.id && response.status) {
-            console.log('SAQUE PROCESSADO COM SUCESSO (PayZu)!');
-            console.log('   ID:', response.id);
-            console.log('   Status:', response.status);
-            // Normalizar resposta (converter para centavos para frontend)
-            return res.json({
-                ...response,
-                amount: Math.round(parseFloat(response.amount) * 100)
-            });
-        } else if (response.statusCode === 401) {
-            console.error('Erro 401: Token inv√°lido');
-            return res.status(401).json({
+        if (!ownerChatId || !amount || !pixKey || !pixKeyType) {
+            return res.status(400).json({
                 error: true,
-                message: 'Token inv√°lido.',
-                details: response
+                message: 'Informe chatid (ou phone), amount, pixKey e pixKeyType.'
             });
         }
 
-        console.error('Erro ao processar saque:', response);
-        return res.status(400).json({
-            error: true,
-            message: response.message || response.error || 'Erro ao processar saque',
-            details: response
+        const amountInReais = (amount / 100).toFixed(2);
+        const user = await getUserByChatId(ownerChatId);
+        const identifier = transactionsService.generateClientReference();
+
+        await transactionsService.registerTransaction(identifier, ownerChatId, 'pix_out', amount, {
+            pixKey,
+            pixKeyType,
+            tokenuser: user?.user_token || CREDPIX_TOKEN || null
         });
 
+        return res.json({
+            success: true,
+            id: identifier,
+            status: 'PENDING',
+            amount,
+            amountReais: amountInReais
+        });
     } catch (error) {
-        if (fs.existsSync(tempScript)) {
-            fs.unlinkSync(tempScript);
-        }
-
-        console.error('üí• Erro cr√≠tico:', error.message);
+        console.error('üí• Erro ao processar saque:', error.message);
         res.status(500).json({
             error: true,
             message: 'Erro ao processar saque',
             details: error.message
         });
     }
 });
 
-// Rota para consultar saldo em conta - PayZu API
+// Rota para consultar saldo em conta - CREDPIX
 app.get('/api/balance', async (req, res) => {
-    const tempScript = `/tmp/balance_${Date.now()}.sh`;
-
     try {
-        console.log('\nCONSULTANDO SALDO EM CONTA (PayZu)');
-
-        // Criar script tempor√°rio
-        const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/user/balance' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
--s`;
-
-        fs.writeFileSync(tempScript, scriptContent, { mode: 0o755 });
-        const output = execSync(`bash ${tempScript}`, { encoding: 'utf-8' });
-        fs.unlinkSync(tempScript);
-
-        const response = JSON.parse(output);
-
-        // PayZu retorna balanceAvailable, balanceBlocked, balanceAvailableWithdraw (em REAIS)
-        if (response.balanceAvailable !== undefined) {
-            console.log('SALDO CONSULTADO COM SUCESSO (PayZu)!');
-            console.log('   Saldo dispon√≠vel: R$', response.balanceAvailable);
-            // Converter para centavos para manter compatibilidade com frontend
-            return res.json({
-                balance: Math.round(parseFloat(response.balanceAvailable) * 100),
-                balanceAvailable: Math.round(parseFloat(response.balanceAvailable) * 100),
-                balanceBlocked: Math.round(parseFloat(response.balanceBlocked || 0) * 100),
-                balanceAvailableWithdraw: Math.round(parseFloat(response.balanceAvailableWithdraw || 0) * 100)
-            });
+        const chatid = req.query.chatid || req.query.phone;
+        if (!chatid) {
+            return res.status(400).json({ error: true, message: 'Informe chatid ou phone.' });
         }
 
-        console.error('Erro ao consultar saldo:', response);
-        return res.status(400).json({
-            error: true,
-            message: response.message || response.error || 'Erro ao consultar saldo',
-            details: response
-        });
-
-    } catch (error) {
-        if (fs.existsSync(tempScript)) {
-            fs.unlinkSync(tempScript);
+        const user = await getUserByChatId(chatid);
+        if (!user) {
+            return res.status(404).json({ error: true, message: 'Usu√°rio n√£o encontrado.' });
         }
 
-        console.error('üí• Erro cr√≠tico:', error.message);
+        const saldoDisponivel = parseFloat(user.saldo || 0);
+        const saldoBloqueado = parseFloat(user.reservado || 0);
+        const saldoSaque = parseFloat(user.limite_saque || saldoDisponivel);
+
+        return res.json({
+            balance: Math.round(saldoDisponivel * 100),
+            balanceAvailable: Math.round(saldoDisponivel * 100),
+            balanceBlocked: Math.round(saldoBloqueado * 100),
+            balanceAvailableWithdraw: Math.round(saldoSaque * 100)
+        });
+    } catch (error) {
+        console.error('üí• Erro ao consultar saldo:', error.message);
         res.status(500).json({
             error: true,
             message: 'Erro ao consultar saldo',
             details: error.message
         });
     }
 });
 
-// Rota para consultar status de PIX In (Dep√≥sito) - PayZu API
+// Rota para consultar status de PIX In (Dep√≥sito) - CREDPIX
 app.get('/api/pix-in/:id', async (req, res) => {
-    const tempScript = `/tmp/pix_in_status_${Date.now()}.sh`;
-
     try {
         const { id } = req.params;
-        console.log('\nüîç CONSULTANDO STATUS DO PIX IN (PayZu) - ID:', id);
-
-        // Criar script tempor√°rio
-        const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/pix/${id}' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
--s`;
-
-        fs.writeFileSync(tempScript, scriptContent, { mode: 0o755 });
-        const output = execSync(`bash ${tempScript}`, { encoding: 'utf-8' });
-        fs.unlinkSync(tempScript);
-
-        const response = JSON.parse(output);
-
-        if (response.id) {
-            console.log('STATUS CONSULTADO (PayZu):', response.status);
-            return res.json({
-                success: true,
-                id: response.id,
-                status: response.status,
-                amount: Math.round(parseFloat(response.amount) * 100), // Converter para centavos
-                expirationDate: response.createdAt,
-                pixCopiaECola: response.qrCodeText || '',
-                qrcode: response.qrCodeBase64 || '',
-                brcode: response.qrCodeText || ''
+        const rows = await db.query(
+            'SELECT identifier, status, valor, data_criacao, brCode FROM pagamentos WHERE identifier = ? LIMIT 1',
+            [id]
+        );
+
+        if (rows.length === 0) {
+            return res.status(404).json({
+                error: true,
+                message: 'PIX n√£o encontrado'
             });
         }
 
-        console.error('Erro ao consultar status:', response);
-        return res.status(404).json({
-            error: true,
-            message: 'PIX n√£o encontrado',
-            details: response
+        const row = rows[0];
+        return res.json({
+            success: true,
+            id: row.identifier,
+            status: row.status,
+            amount: Math.round(parseFloat(row.valor) * 100),
+            expirationDate: row.data_criacao,
+            pixCopiaECola: row.brCode || '',
+            brcode: row.brCode || ''
         });
-
     } catch (error) {
-        if (fs.existsSync(tempScript)) {
-            fs.unlinkSync(tempScript);
-        }
-
-        console.error('üí• Erro cr√≠tico:', error.message);
+        console.error('üí• Erro ao consultar status:', error.message);
         res.status(500).json({
             error: true,
             message: 'Erro ao consultar status',
             details: error.message
         });
     }
 });
 
-// Rota para consultar status de PIX Out (Saque) - PayZu API
+// Rota para consultar status de PIX Out (Saque) - CREDPIX
 app.get('/api/pix-out/:id', async (req, res) => {
-    const tempScript = `/tmp/pix_out_status_${Date.now()}.sh`;
-
     try {
         const { id } = req.params;
-        console.log('\nüîç CONSULTANDO STATUS DO SAQUE (PayZu) - ID:', id);
-
-        // Criar script tempor√°rio - PayZu usa mesmo endpoint /pix/{id} para consultar
-        const scriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/pix/${id}' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
--s`;
-
-        fs.writeFileSync(tempScript, scriptContent, { mode: 0o755 });
-        const output = execSync(`bash ${tempScript}`, { encoding: 'utf-8' });
-        fs.unlinkSync(tempScript);
-
-        const response = JSON.parse(output);
-
-        if (response.id) {
-            console.log('STATUS DO SAQUE (PayZu):', response.status);
-            // Normalizar resposta (converter para centavos)
-            return res.json({
-                ...response,
-                amount: Math.round(parseFloat(response.amount) * 100)
+        const rows = await db.query(
+            'SELECT txid, status, value, created_at FROM saques_pix WHERE txid = ? LIMIT 1',
+            [id]
+        );
+
+        if (rows.length === 0) {
+            return res.status(404).json({
+                error: true,
+                message: 'Saque n√£o encontrado'
             });
         }
 
-        console.error('Erro ao consultar status:', response);
-        return res.status(404).json({
-            error: true,
-            message: 'Saque n√£o encontrado',
-            details: response
+        const row = rows[0];
+        return res.json({
+            id: row.txid,
+            status: row.status,
+            amount: Math.round(parseFloat(row.value) * 100),
+            createdAt: row.created_at
         });
-
     } catch (error) {
-        if (fs.existsSync(tempScript)) {
-            fs.unlinkSync(tempScript);
-        }
-
-        console.error('üí• Erro cr√≠tico:', error.message);
+        console.error('üí• Erro ao consultar status:', error.message);
         res.status(500).json({
             error: true,
             message: 'Erro ao consultar status',
             details: error.message
         });
     }
 });
 
 // Rota de status
 app.get('/api/status', (req, res) => {
     res.json({
         status: 'online',
         mode: 'PRODUCTION',
-        message: 'Sistema conectado √† API PayZu',
+        message: 'Sistema conectado √† CREDPIX',
         apiStatus: 'FUNCIONANDO',
         pixIn: true,
         pixOut: true,
         timestamp: new Date().toISOString()
     });
 });
 
 // ========== ROTAS DO PAINEL ADMIN ==========
 // Todas as rotas /admin e /api/admin s√£o protegidas por IP
 
 // P√°gina do painel admin
 app.get('/admin', requireAdminIP, (req, res) => {
     res.sendFile(path.join(__dirname, 'admin.html'));
 });
 
 // Status da configura√ß√£o admin
 app.get('/api/admin/config-status', requireAdminIP, (req, res) => {
     res.json(adminAuth.getConfigStatus());
 });
 
 // Setup inicial do 2FA
 app.post('/api/admin/setup-2fa', requireAdminIP, async (req, res) => {
     try {
         const { password } = req.body;
 
@@ -2822,158 +2397,126 @@ app.get('/api/bots', requireAdminIP, adminAuth.requireAuth, (req, res) => {
         // N√£o expor tokens completos na listagem
         const safeBots = bots.map(b => ({
             id: b.id,
             name: b.name,
             brandName: b.brandName,
             whatsappNumber: b.whatsappNumber,
             active: b.active !== false
         }));
         res.json(safeBots);
     } catch (error) {
         console.error('Erro ao listar bots:', error.message);
         res.status(500).json({ error: error.message });
     }
 });
 
 // ========== ROTAS DE TENANTS (PROTEGIDAS) ==========
 // Requer IP permitido + autentica√ß√£o admin
 
 // Listar todos os tenants
 app.get('/api/tenants', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
         const tenants = tenantService.listTenants();
         // N√£o expor tokens completos na listagem
         const safeTenants = tenants.map(t => ({
             ...t,
-            payzuToken: t.payzuToken ? `${t.payzuToken.substring(0, 10)}...` : null
+            platformToken: t.platformToken ? `${t.platformToken.substring(0, 10)}...` : null
         }));
         res.json(safeTenants);
     } catch (error) {
         console.error('Erro ao listar tenants:', error.message);
         res.status(500).json({ error: error.message });
     }
 });
 
 // Obter estat√≠sticas dos tenants
 app.get('/api/tenants/stats', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
         res.json(tenantService.getStats());
     } catch (error) {
         res.status(500).json({ error: error.message });
     }
 });
 
 // Criar novo tenant
 app.post('/api/tenants', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
-        const { name, payzuToken, myPixKey, authorizedNumbers } = req.body;
+        const { name, platformToken, myPixKey, authorizedNumbers } = req.body;
 
-        if (!name || !payzuToken) {
-            return res.status(400).json({ error: 'Nome e token PayZu s√£o obrigat√≥rios' });
+        if (!name || !platformToken) {
+            return res.status(400).json({ error: 'Nome e token CREDPIX s√£o obrigat√≥rios' });
         }
 
         const tenant = tenantService.createTenant({
             name,
-            payzuToken,
+            platformToken,
             myPixKey,
             authorizedNumbers: authorizedNumbers || []
         });
 
         res.status(201).json(tenant);
     } catch (error) {
         console.error('Erro ao criar tenant:', error.message);
         res.status(400).json({ error: error.message });
     }
 });
 
 // Obter tenant espec√≠fico
 app.get('/api/tenants/:id', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
         const tenant = tenantService.getTenantById(req.params.id);
         if (!tenant) {
             return res.status(404).json({ error: 'Cliente n√£o encontrado' });
         }
         res.json(tenant);
     } catch (error) {
         res.status(500).json({ error: error.message });
     }
 });
 
 // Atualizar tenant
 app.put('/api/tenants/:id', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
         const tenant = tenantService.updateTenant(req.params.id, req.body);
         res.json(tenant);
     } catch (error) {
         console.error('Erro ao atualizar tenant:', error.message);
         res.status(400).json({ error: error.message });
     }
 });
 
 // Deletar tenant
 app.delete('/api/tenants/:id', requireAdminIP, adminAuth.requireAuth, (req, res) => {
     try {
         tenantService.deleteTenant(req.params.id);
         res.json({ success: true, message: 'Cliente removido' });
     } catch (error) {
         console.error('Erro ao deletar tenant:', error.message);
         res.status(400).json({ error: error.message });
     }
 });
 
 // Iniciar servidor
 app.listen(PORT, () => {
     console.log(`
     ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-    ‚ïë   PayZu PIX Manager - FUNCIONANDO!       ‚ïë
+    ‚ïë   CREDPIX PIX Manager - FUNCIONANDO!     ‚ïë
     ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
     ‚ïë                                              ‚ïë
     ‚ïë  üöÄ Servidor rodando em:                     ‚ïë
     ‚ïë     http://localhost:${PORT}                  ‚ïë
     ‚ïë                                              ‚ïë
     ‚ïë  üìÅ Acesse o sistema em:                     ‚ïë
     ‚ïë     http://localhost:${PORT}/index.html       ‚ïë
     ‚ïë                                              ‚ïë
-    ‚ïë  Status: API PayZu FUNCIONANDO           ‚ïë
-    ‚ïë  PIX In: Gerando PIX pag√°vel             ‚ïë
-    ‚ïë  PIX Out: Processando saques reais       ‚ïë
+    ‚ïë  Status: CREDPIX ATIVA                       ‚ïë
+    ‚ïë  PIX In: Gerando cobran√ßas                   ‚ïë
+    ‚ïë  PIX Out: Processando saques                 ‚ïë
     ‚ïë                                              ‚ïë
-    ‚ïë   LEMBRE: Saques requerem IP fixo!       ‚ïë
+    ‚ïë   LEMBRE: Saques requerem valida√ß√£o!     ‚ïë
     ‚ïë                                              ‚ïë
     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 
-    üí° Esta vers√£o usa a API PayZu.
-    üìå Base URL: ${PAYZU_BASE_URL}
+    üí° Esta vers√£o usa o banco CREDPIX.
+    üìå Base URL configurada: ${CREDPIX_BASE_URL || 'n√£o definida'}
     `);
-
-    // Testar conex√£o com API PayZu (apenas consulta de saldo)
-    console.log('\nüîç Testando conex√£o com API PayZu...');
-
-    const testScript = `/tmp/test_startup_${Date.now()}.sh`;
-    const testScriptContent = `#!/bin/bash
-curl --location '${PAYZU_BASE_URL}/user/balance' \\
---header 'Accept: application/json' \\
---header 'Authorization: Bearer ${PAYZU_TOKEN}' \\
--s -w "\\nSTATUS:%{http_code}"`;
-
-    try {
-        fs.writeFileSync(testScript, testScriptContent, { mode: 0o755 });
-        const result = execSync(`bash ${testScript}`, { encoding: 'utf-8' });
-        fs.unlinkSync(testScript);
-
-        if (result.includes('STATUS:200')) {
-            console.log('API PayZu est√° funcionando!');
-            console.log('   Voc√™ pode gerar PIX real agora.');
-        } else if (result.includes('STATUS:401')) {
-            console.log('Token PayZu inv√°lido ou expirado!');
-            console.log('   Atualize PAYZU_TOKEN no arquivo .env');
-        } else {
-            console.log('Erro ao conectar com API PayZu');
-            console.log('   Resposta:', result);
-        }
-    } catch (error) {
-        if (fs.existsSync(testScript)) {
-            fs.unlinkSync(testScript);
-        }
-        console.log('Erro ao testar API:', error.message);
-    }
 });
 
EOF
)